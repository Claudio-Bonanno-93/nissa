%pure-parser
%locations
%defines
%error-verbose
%parse-param {driver_t *driver}
%lex-param {void *scanner}

%{
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "nissa.hpp"
#include "driver.hpp"
#include "parser.hpp"
#include "redefine_yy.hpp"

  const int debug_parser=0;
  
  int parser_lex(YYSTYPE *lvalp,YYLTYPE *llocp,void *scanner);
  void parser_error(YYLTYPE *locp,driver_t *driver,const char *err)
  {crash("exception %d %s",locp->first_line,err);}

#define scanner driver->scanner
  %}

 //union used to catch all symbols
%union
{
    double double_numb;
    int int_numb;
    char *text;
    gauge_action_name_t gauge_action_name;
    smooth_pars_t *smooth_pars;
    stout_pars_t *stout_pars;
    cool_pars_t *cool_pars;
    ape_pars_t *ape_pars;
    hyp_pars_t *hyp_pars;
    Wflow_pars_t *Wflow_pars;
    std::vector<int> *int_list;
    std::vector<double> *double_list;
    std::pair<int,int> *int_pair;
    std::vector<std::pair<int,int> > *int_pair_list;
}

//arithmethc
%left TK_MINUS TK_PLUS
%left TK_TIMES TK_DIV
%precedence NEG
%right TK_POW

//geometry
%token TK_GEOMETRY
%token TK_L
%token TK_T
//gauge pars
%token TK_GAUGE_PARS
%token TK_BETA
//general pars
%token <double_numb> TK_DOUBLE
%type <double_numb> double_numb
%token <int_numb> TK_INT
%token <int_numb> TK_QUANTITY
%type <int_numb> int_numb
%type <int_pair> int_pair
%type <int_list> int_list
%type <int_list> internal_int_list
%type <double_list> double_list
%type <double_list> internal_double_list
%type <int_pair_list> int_pair_list
%type <int_pair_list> internal_int_pair_list
%token <text> TK_QUOTED_TEXT
%token TK_COMMA
%token TK_BR_OP
%token TK_BR_CL
%token TK_CUR_BR_OP
%token TK_CUR_BR_CL
//each
%token <int_numb> TK_EACH
%type <int_numb> each
//after
%token <int_numb> TK_AFTER
%type <int_numb> after
//yes no none
%token TK_NONE TK_YES TK_NO
//residue
%token <double_numb> TK_RESIDUE
%type <double_numb> residue
//metadynamics
%token TK_META
%token TK_ORDINARY
%token TK_TOPO_POTENTIAL
//path
%token TK_PATH
%type <text> path
//meta commands
%token TK_META_PRINT_SCANNED
%token TK_META_PRINT_FULL
//quark content
%token TK_QUARK
%token TK_DEGENERACY
%type <int_numb> degeneracy
%token TK_IS_STAG
%type <int_numb> is_stag
%token TK_KAPPA
%type <double_numb> kappa
%token TK_MASS
%type <double_numb> mass
%token TK_RE_POT_CH
%type <double_numb> re_pot_ch
%token TK_IM_POT_CH
%type <double_numb> im_pot_ch
%token TK_ELEC_CHARGE
%type <double_numb> elec_charge
//smooth method
%token TK_SMOOTH_METHOD
%token TK_STOUT
%token TK_COOLING
%token TK_HYP
%token TK_APE
%token TK_WFLOW
%token TK_MEAS_EACH
%type <smooth_pars> smooth_pars
//stout pars
%token TK_STOUT_PARS
%type <stout_pars> stout_pars
%token TK_NLEVELS
%type <int_numb> nlevels
%token TK_RHO
%type <double_numb> rho
//cooling pars
%token TK_COOL_PARS
%type <cool_pars> cool_pars
%token TK_NSTEPS
%type <int_numb> nsteps
//ape pars
%token TK_APE_PARS
%type <ape_pars> ape_pars
%token TK_ALPHA
%type <double_numb> alpha
//hyp pars
%token TK_HYP_PARS
%type <hyp_pars> hyp_pars
%token TK_ALPHAS
%type <double_list> alphas
//wflow pars
%token TK_WFLOW_PARS
%type <Wflow_pars> Wflow_pars
%token TK_FLOW_TIME
%type <double_numb> flow_time
%token TK_INTE_STEP
%type <double_numb> inte_step
//gauge action
%token TK_ACTION
%token TK_WILSON
%token TK_TLSYM
%token TK_IWASAKI
%type <gauge_action_name> action
//background field
%token TK_BKGRD_EM_FIELD
%token <int_numb> TK_B_COMP
%token <int_numb> TK_E_COMP
//number of copies and hits
%token TK_NCOPIES TK_NHITS
%type <int_numb> ncopies nhits
//meson corr
%token TK_MEAS_MESON_CORRS
%token TK_MESON_LIST
%type <int_pair_list> meson_list
//nucleon corr
%token TK_MEAS_NUCLEON_CORRS
//putpourri
%token TK_MEAS_PUTPOURRI
%token TK_COMPUTE_SUSC
%type <int_numb> compute_susc
//rendens
%token TK_MEAS_RENDENS
//magnetization
%token TK_MEAS_MAGNETIZ
//gauge measures
%token TK_MEAS_PLAQ_POL
%token TK_MEAS_TOP
%token TK_MEAS_LUPPOLI
%token TK_MEAS_WATUSSO
%token TK_MEAS_ALL_RECTS
//evolution parameters
%token TK_EVOLUTION
%token TK_NTRAJ_TOT
%token TK_SKIP_METRO
%token TK_TRAJ_LENGTH
%token TK_ACT_RESIDUE
%token TK_MD_RESIDUE
%token TK_NSUBSTEPS
%token TK_NPSEUDO_FERMS
//conf parameters
%token TK_CONFIGURATION
%token TK_STORE_PATH
%token TK_STORE_EACH
%token TK_STORE_RUNNING
%token TK_START_COND
%token TK_HOT
%token TK_COLD
//run pars
%token TK_RUN
%token TK_WALLTIME
%token TK_SEED
%%

commands: commands command
        | command
;

command: global_specify
       | meta_command
;

global_specify: geometry
              | gauge_pars
              | topo_potential_pars
              | add_quark
              | stout_pars {driver->stout_pars=(*$1);};
              | bckgr_field
/////////////// fermionic measures ////////////////
              | meson_corr_meas
              | nucleon_corr_meas
              | fermionic_putpourri_meas
              | quark_rendens_meas
              | magnetization_meas
/////////////// gauge measures ////////////////////
              | plaq_pol_meas
              | top_meas
              | luppoli_meas
              | watusso_meas
              | all_rect_meas
/////////////// evolve and confpars ///////////////////////
              | global_evolve_pars
              | global_conf_pars
//////////////// walltime and seed /////////////////
              | run_pars
;

meta_command: meta_print_scanned
            | meta_print_full
;

meta_print_scanned: TK_META_PRINT_SCANNED TK_QUOTED_TEXT {FILE *fout=open_file($2,"w");driver->master_fprintf(fout);close_file(fout);}
meta_print_full: TK_META_PRINT_FULL TK_QUOTED_TEXT {FILE *fout=open_file($2,"w");driver->master_fprintf(fout,true);close_file(fout);}

//////////////////////////////////////////////// SIMPLE STUFF //////////////////////////////////////////////////

action: TK_ACTION '=' TK_WILSON {$$=WILSON_GAUGE_ACTION;};
      | TK_ACTION '=' TK_TLSYM {$$=TLSYM_GAUGE_ACTION;};
      | TK_ACTION '=' TK_IWASAKI {$$=IWASAKI_GAUGE_ACTION;};

each: TK_EACH '=' int_numb {$$=$3;};

after: TK_AFTER '=' int_numb {$$=$3;};

residue: TK_RESIDUE '=' double_numb {$$=$3;};

ncopies: TK_NCOPIES '=' int_numb {$$=$3;};

nhits: TK_NHITS '=' int_numb {$$=$3;};

compute_susc: TK_COMPUTE_SUSC '=' int_numb {$$=$3;};

path: TK_PATH '=' TK_QUOTED_TEXT {$$=$3;};

geometry: TK_GEOMETRY
        | geometry TK_T '=' int_numb {driver->T=$4;}
        | geometry TK_L '=' int_numb {driver->L=$4;}
;

gauge_pars: TK_GAUGE_PARS
          | gauge_pars TK_BETA '=' double_numb {driver->beta=$4;}
          | gauge_pars action {driver->gauge_action_name=$2;}
;

run_pars: TK_RUN {}
        | run_pars TK_WALLTIME '=' int_numb {driver->walltime=$4;}
        | run_pars TK_SEED '=' int_numb {driver->seed=$4;}
;

////////////////////////////////////////////// TOPO POTENTIAL //////////////////////////////////////////////////

//specify topopotential pars
topo_potential_pars: TK_TOPO_POTENTIAL '=' TK_META {driver->topotential_pars.flag=2;}
                   | TK_TOPO_POTENTIAL '=' TK_ORDINARY {driver->topotential_pars.flag=1;}
                   | TK_TOPO_POTENTIAL '=' TK_NONE {driver->topotential_pars.flag=0;}
;

////////////////////////////////////////////////// SMOOTH PARS /////////////////////////////////////////////////

smooth_pars: TK_SMOOTH_METHOD '=' TK_STOUT {$$=new smooth_pars_t;$$->method=smooth_pars_t::STOUT;}
           | TK_SMOOTH_METHOD '=' TK_COOLING {$$=new smooth_pars_t;$$->method=smooth_pars_t::COOLING;}
           | TK_SMOOTH_METHOD '=' TK_WFLOW {$$=new smooth_pars_t;$$->method=smooth_pars_t::WFLOW;}
           | TK_SMOOTH_METHOD '=' TK_APE {$$=new smooth_pars_t;$$->method=smooth_pars_t::APE;}
           | TK_SMOOTH_METHOD '=' TK_HYP {$$=new smooth_pars_t;$$->method=smooth_pars_t::HYP;}
           | smooth_pars stout_pars {$$->stout_pars=(*$2);}
           | smooth_pars cool_pars {$$->cool_pars=(*$2);}
           | smooth_pars Wflow_pars {$$->Wflow_pars=(*$2);}
           | smooth_pars ape_pars {$$->ape_pars=(*$2);}
           | smooth_pars hyp_pars {$$->hyp_pars=(*$2);}
           | smooth_pars TK_MEAS_EACH '=' double_numb {$$->meas_each=$4;}
;

////////////////////////////////////////////////// STOUT PARS //////////////////////////////////////////////////

stout_pars: TK_STOUT_PARS {$$=new stout_pars_t;}
          | stout_pars nlevels {$$=$1;$$->nlevels=$2;}
          | stout_pars rho {$$=$1;$$->rho=$2;}
;

nlevels: TK_NLEVELS '=' int_numb {$$=$3;};
rho: TK_RHO '=' double_numb {$$=$3;};

////////////////////////////////////////////////// COOL PARS //////////////////////////////////////////////////

cool_pars: TK_COOL_PARS {$$=new cool_pars_t;}
         | cool_pars nsteps {$$=$1;$$->nsteps=$2;}
         | cool_pars action {$$=$1;$$->gauge_action=$2;}
;

nsteps: TK_NSTEPS '=' int_numb {$$=$3;};

////////////////////////////////////////////////// APE PARS //////////////////////////////////////////////////

ape_pars: TK_APE_PARS {$$=new ape_pars_t;}
        | ape_pars nlevels {$$=$1;$$->nlevels=$2;}
        | ape_pars alpha {$$=$1;$$->alpha=$2;}
;

alpha: TK_ALPHA '=' double_numb {$$=$3;};

////////////////////////////////////////////////// APE PARS //////////////////////////////////////////////////

hyp_pars: TK_HYP_PARS {$$=new hyp_pars_t;}
        | hyp_pars nlevels {$$=$1;$$->nlevels=$2;}
        | hyp_pars alphas {
	    $$=$1;
	    if($2->size()!=3) crash("hyp alpha needs an exactly 3 long list of int");
	    $$->alpha0=(*$2)[0];
	    $$->alpha1=(*$2)[1];
	    $$->alpha2=(*$2)[2];
	    }
;

alphas: TK_ALPHAS '=' double_list {$$=$3;};

////////////////////////////////////////////////// WFLOW PARS //////////////////////////////////////////////////

Wflow_pars: TK_WFLOW_PARS {$$=new Wflow_pars_t;}
          | Wflow_pars flow_time {$$=$1;$$->T=$2;}
          | Wflow_pars inte_step {$$=$1;$$->dt=$2;}
;

flow_time: TK_FLOW_TIME '=' double_numb {$$=$3;};
inte_step: TK_INTE_STEP '=' double_numb {$$=$3;};

////////////////////////////////////////////////// QUARK CONTENT //////////////////////////////////////////////////

add_quark: name_quark quark_pars;

name_quark: TK_QUARK '=' TK_QUOTED_TEXT
          {
	      quark_content_t q;
	      q.name=$3;
	      driver->quarks.push_back(q);
	  }
;

quark_pars: quark_pars quark_par
          | quark_par
;

quark_par: degeneracy {driver->quarks.back().deg=$1;}
         | is_stag {driver->quarks.back().is_stag=$1;}
         | mass {driver->quarks.back().mass=$1;}
         | kappa {driver->quarks.back().kappa=$1;}
         | re_pot_ch {driver->quarks.back().re_pot=$1;}
         | im_pot_ch {driver->quarks.back().im_pot=$1;}
         | elec_charge {driver->quarks.back().charge=$1;}
;

degeneracy: TK_DEGENERACY '=' int_numb {$$=$3;};
is_stag: TK_IS_STAG '=' int_numb {$$=true;};
mass: TK_MASS '=' double_numb {$$=$3;};
kappa: TK_KAPPA '=' double_numb {$$=$3;};
re_pot_ch: TK_RE_POT_CH '=' double_numb {$$=$3;};
im_pot_ch: TK_IM_POT_CH '=' double_numb {$$=$3;};
elec_charge: TK_ELEC_CHARGE '=' double_numb {$$=$3;};

////////////////////////////////////////////////// BACKGROUND FIELD //////////////////////////////////////////////////

bckgr_field: TK_BKGRD_EM_FIELD {driver->em_field_pars.flag=1;}
           | bckgr_field TK_E_COMP '=' double_numb {driver->em_field_pars.E[$2]=$4;}
           | bckgr_field TK_B_COMP '=' double_numb {driver->em_field_pars.B[$2]=$4;}
;

////////////////////////////////////////////////// NUCLEON CORR //////////////////////////////////////////////////

nucleon_corr_meas: TK_MEAS_NUCLEON_CORRS {driver->nucleon_corr_meas.push_back(nucleon_corr_meas_pars_t());}
                 | nucleon_corr_meas each {driver->nucleon_corr_meas.back().each=$2;}
                 | nucleon_corr_meas after {driver->nucleon_corr_meas.back().after=$2;}
                 | nucleon_corr_meas path {driver->nucleon_corr_meas.back().path=$2;}
                 | nucleon_corr_meas residue {driver->nucleon_corr_meas.back().residue=$2;}
                 | nucleon_corr_meas nhits {driver->nucleon_corr_meas.back().nhits=$2;}
;

////////////////////////////////////////////////// MESON CORR //////////////////////////////////////////////////

meson_corr_meas: TK_MEAS_MESON_CORRS {driver->meson_corr_meas.push_back(meson_corr_meas_pars_t());}
               | meson_corr_meas each {driver->meson_corr_meas.back().each=$2;}
               | meson_corr_meas after {driver->meson_corr_meas.back().after=$2;}
               | meson_corr_meas path {driver->meson_corr_meas.back().path=$2;}
               | meson_corr_meas residue {driver->meson_corr_meas.back().residue=$2;}
               | meson_corr_meas nhits {driver->meson_corr_meas.back().nhits=$2;}
               | meson_corr_meas meson_list {driver->meson_corr_meas.back().mesons=*$2;}
;

meson_list: TK_MESON_LIST '=' int_pair_list {
    if((*$3)[0]!=std::make_pair(15,15)) crash("first entry of the meson list must be 15,15, instead it is: %d %d",(*$$)[0].first,(*$$)[0].second);
    for(size_t i=0;i<$3->size();i++)
	{
	    int f=(*$3)[i].first;
	    int s=(*$3)[i].second;
	    if((f<0)||(f>15)) crash("first part of entry %d is %d, should be in the range [0,15]",f);
	    if((s<0)||(s>15)) crash("second part of entry %d is %d, should be in the range [0,15]",s);
        }
	$$=$3;}
;


////////////////////////////////////////////////// FERMIONIC POUTPURRI //////////////////////////////////////////////////

fermionic_putpourri_meas: TK_MEAS_PUTPOURRI {driver->fermionic_putpourri_meas.push_back(fermionic_putpourri_meas_pars_t());}
                        | fermionic_putpourri_meas each {driver->fermionic_putpourri_meas.back().each=$2;}
                        | fermionic_putpourri_meas after {driver->fermionic_putpourri_meas.back().after=$2;}
                        | fermionic_putpourri_meas path {driver->fermionic_putpourri_meas.back().path=$2;}
                        | fermionic_putpourri_meas residue {driver->fermionic_putpourri_meas.back().residue=$2;}
                        | fermionic_putpourri_meas compute_susc {driver->fermionic_putpourri_meas.back().compute_susc=$2;}
                        | fermionic_putpourri_meas ncopies {driver->fermionic_putpourri_meas.back().ncopies=$2;}
                        | fermionic_putpourri_meas nhits {driver->fermionic_putpourri_meas.back().nhits=$2;}
;

////////////////////////////////////////////////// RENDENS //////////////////////////////////////////////////

quark_rendens_meas: TK_MEAS_RENDENS {driver->quark_rendens_meas.push_back(quark_rendens_meas_pars_t());}
                  | quark_rendens_meas each {driver->quark_rendens_meas.back().each=$2;}
                  | quark_rendens_meas after {driver->quark_rendens_meas.back().after=$2;}
                  | quark_rendens_meas path {driver->quark_rendens_meas.back().path=$2;}
                  | quark_rendens_meas residue {driver->quark_rendens_meas.back().residue=$2;}
                  | quark_rendens_meas ncopies {driver->quark_rendens_meas.back().ncopies=$2;}
                  | quark_rendens_meas nhits {driver->quark_rendens_meas.back().nhits=$2;}
;

////////////////////////////////////////////////// MAGNETIZATION //////////////////////////////////////////////////

magnetization_meas: TK_MEAS_MAGNETIZ {driver->magnetization_meas.push_back(magnetization_meas_pars_t());}
                  | magnetization_meas each {driver->magnetization_meas.back().each=$2;}
                  | magnetization_meas after {driver->magnetization_meas.back().after=$2;}
                  | magnetization_meas path {driver->magnetization_meas.back().path=$2;}
                  | magnetization_meas residue {driver->magnetization_meas.back().residue=$2;}
                  | magnetization_meas ncopies {driver->magnetization_meas.back().ncopies=$2;}
                  | magnetization_meas nhits {driver->magnetization_meas.back().nhits=$2;}
;

////////////////////////////////////////////////// EVOLUTION //////////////////////////////////////////////////

global_evolve_pars: TK_EVOLUTION {}
                  | global_evolve_pars TK_NTRAJ_TOT '=' int_numb {driver->evol_pars.ntraj_tot=$4;}
                  | global_evolve_pars TK_SKIP_METRO '=' int_numb {driver->evol_pars.skip_mtest_ntraj=$4;}
                  | global_evolve_pars TK_TRAJ_LENGTH '=' double_numb {driver->evol_pars.traj_length=$4;}
                  | global_evolve_pars TK_ACT_RESIDUE '=' double_numb {driver->evol_pars.pf_action_residue=$4;}
                  | global_evolve_pars TK_MD_RESIDUE '=' double_numb {driver->evol_pars.md_residue=$4;}
                  | global_evolve_pars TK_NSTEPS '=' int_numb {driver->evol_pars.nmd_steps=$4;}
                  | global_evolve_pars TK_NSUBSTEPS '=' int_numb {driver->evol_pars.ngauge_substeps=$4;}
                  | global_evolve_pars TK_NPSEUDO_FERMS '=' int_list {driver->evol_pars.npseudo_fs=(*$4);}
;

////////////////////////////////////////////////// CONF PARS ///////////////////////////////////////////////////

global_conf_pars: TK_CONFIGURATION {}
                | global_conf_pars path {driver->conf_pars.path=$2;}
                | global_conf_pars TK_STORE_PATH '=' TK_QUOTED_TEXT {
                        driver->conf_pars.store_path=$4;
                        char test1[128];
                        char test2[128];
                        snprintf(test1,128,$4,100);
                        snprintf(test2,128,$4,101);
                        if(!strcmp(test1,test2)) crash("bad template %s for store_path",$4);}
                | global_conf_pars TK_STORE_EACH '=' int_numb {driver->conf_pars.store_each=$4;}
                | global_conf_pars TK_STORE_RUNNING '=' int_numb {driver->conf_pars.store_running=$4;}
                | global_conf_pars TK_START_COND '=' TK_HOT {driver->conf_pars.start_cond=HOT_START_COND;}
                | global_conf_pars TK_START_COND '=' TK_COLD {driver->conf_pars.start_cond=COLD_START_COND;}
;

/////////////////////////////////////////// PLAQ AND POLYAKOV LOOP //////////////////////////////////////////////////

plaq_pol_meas: TK_MEAS_PLAQ_POL {driver->plaq_pol_meas.push_back(gauge_obs_meas_pars_t());}
             | plaq_pol_meas each {driver->plaq_pol_meas.back().each=$2;}
             | plaq_pol_meas after {driver->plaq_pol_meas.back().after=$2;}
             | plaq_pol_meas path {driver->plaq_pol_meas.back().path=$2;}
;

//////////////////////////////////////////////// TOPO CHARGE ////////////////////////////////////////////////////////

top_meas: TK_MEAS_TOP {driver->top_meas.push_back(top_meas_pars_t());}
        | top_meas each {driver->top_meas.back().each=$2;}
        | top_meas after {driver->top_meas.back().after=$2;}
        | top_meas path {driver->top_meas.back().path=$2;}
        | top_meas smooth_pars {driver->top_meas.back().smooth_pars=(*$2);}
;

//////////////////////////////////////////// POLYAKOV LOOP CORRELATORS /////////////////////////////////////////////

luppoli_meas: TK_MEAS_LUPPOLI {driver->luppoli_meas.push_back(poly_corr_meas_pars_t());}
            | luppoli_meas each {driver->luppoli_meas.back().each=$2;}
            | luppoli_meas after {driver->luppoli_meas.back().after=$2;}
            | luppoli_meas path {driver->luppoli_meas.back().path=$2;}
;

/////////////////////////////////////////////////////// WATUSSO /////////////////////////////////////////////////////

watusso_meas: TK_MEAS_WATUSSO {driver->watusso_meas.push_back(watusso_meas_pars_t());}
            | watusso_meas each {driver->watusso_meas.back().each=$2;}
            | watusso_meas after {driver->watusso_meas.back().after=$2;}
            | watusso_meas path {driver->watusso_meas.back().path=$2;}
;

/////////////////////////////////////////// RECTANGLES OF VARIOUS SIZE /////////////////////////////////////////////

all_rect_meas: TK_MEAS_ALL_RECTS {driver->all_rect_meas.push_back(all_rect_meas_pars_t());}
             | all_rect_meas each {driver->all_rect_meas.back().each=$2;}
             | all_rect_meas after {driver->all_rect_meas.back().after=$2;}
             | all_rect_meas path {driver->all_rect_meas.back().path=$2;}
;

/////////////////////////////////////////////// LIST OF INTEGERS ///////////////////////////////////////////////////

int_list: internal_int_list TK_CUR_BR_CL {$$=$1;}
;

internal_int_list: TK_CUR_BR_OP int_numb {$$=new std::vector<int>;$$->push_back($2);}
                 | internal_int_list TK_COMMA int_numb {$$->push_back($3);}
;

/////////////////////////////////////////////// LIST OF DOUBLE ///////////////////////////////////////////////////

double_list: internal_double_list TK_CUR_BR_CL {$$=$1;}
;

internal_double_list: TK_CUR_BR_OP double_numb {$$=new std::vector<double>;$$->push_back($2);}
                    | internal_double_list TK_COMMA double_numb {$$->push_back($3);}
;

/////////////////////////////////////////// LIST OF PAIR OF INTEGERS ///////////////////////////////////////////////

int_pair_list: internal_int_pair_list TK_CUR_BR_CL {$$=$1;}
;

internal_int_pair_list: TK_CUR_BR_OP int_pair {$$=new std::vector<std::pair<int,int> >;$$->push_back(*$2);}
                      | internal_int_pair_list TK_COMMA int_pair {$$->push_back(*$3);}
;

/////////////////////////////////////////////// PAIR OF INTEGERS ///////////////////////////////////////////////////

int_pair: TK_BR_OP int_numb TK_COMMA int_numb TK_BR_CL {$$=new std::pair<int,int>; (*$$)=std::make_pair($2,$4);}
;

//////////////////////////////////////////////////// ARITHMETIC //////////////////////////////////////////////////////

//double
double_numb: TK_DOUBLE {$$=$1;master_printf("Copying %lg to double\n",$1);}
         | int_numb {$$=$1;master_printf("Casting %d to double\n",$1);}
         | TK_PLUS double_numb %prec NEG {$$=$2;}
         | TK_MINUS double_numb %prec NEG {$$=-$2;}
         | double_numb TK_PLUS double_numb {$$=$1+$3;}
         | double_numb TK_MINUS double_numb {$$=$1-$3;}
         | double_numb TK_TIMES double_numb {$$=$1*$3;}
         | double_numb TK_DIV double_numb {$$=$1/$3;}
         | double_numb TK_POW double_numb {$$=pow($1,$3);}
         | TK_BR_OP double_numb TK_BR_CL {$$=$2;}
;

//integer
int_numb: TK_INT {$$=$1;master_printf("Copying %d to integer\n",$1);}
        | TK_PLUS int_numb %prec NEG {$$=$2;}
        | TK_MINUS int_numb %prec NEG {$$=-$2;}
        | int_numb TK_PLUS int_numb {$$=$1+$3;}
        | int_numb TK_MINUS int_numb {$$=$1-$3;}
        | int_numb TK_QUANTITY {$$=$1*$2;}
        | int_numb TK_TIMES int_numb {$$=$1*$3;}
        | int_numb TK_DIV int_numb {$$=$1/$3;}
        | int_numb TK_POW int_numb {$$=(int)pow($1,$3);}
        | TK_BR_OP int_numb TK_BR_CL {$$=$2;}
;

