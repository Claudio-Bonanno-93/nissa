#ifndef _METADYNAMICS_HPP
#define _METADYNAMICS_HPP

#include <math.h>
#include <string>
#include <vector>

#include "../routines/math_routines.hpp"
#include "../routines/ios.hpp"

namespace nissa
{
  struct meta_pars_t
  {
    int after;
    int each;
    double coeff;
    double width;
    double barr;
    double force_out;
    double well_tempering;
    double bend;
    
    int ngrid;
    std::vector<double> grid;
    
    std::string path;
    meta_pars_t(const char *in_path)
    {path=in_path;}
    
    //update the history-dependent potential
    void update(int isweep,double Q)
    {
      if(isweep>=after && (isweep-after)%each==0)
	{
	  int igrid=floor(Q/width)+ngrid/2;
	  double alpha=Q/width;
	  alpha=alpha-floor(alpha);
	  if(igrid>=0 && igrid<=ngrid) grid[igrid]+=(1-alpha)*coeff;
	  if(igrid+1>=0 && igrid+1<=ngrid) grid[igrid+1]+=alpha*coeff;
	}
    }
    
    //compute the derivative of the potential
    double compute_pot_der(double x)
    {
      //take igrid
      int igrid=floor((x+barr)/width);
      
      //inside the barriers
      if(igrid>=0 && igrid<ngrid)
	return (grid[igrid+1]-grid[igrid])/width;
      else
	if(igrid<0)
	  return -force_out*(-x-barr);
	else
	  return +force_out*(+x-barr);
    }
    
    //compute the potential using past history
    double compute_pot(double x)
    {
      //take igrid
      int igrid=floor((x+barr)/width);
      
      //inside the barriers
      if(igrid>=0 && igrid<ngrid)
	{
	  //interpolate
	  double x0=igrid*width-barr;
	  double m=(grid[igrid+1]-grid[igrid])/width;
	  double q=grid[igrid]-m*x0;
	  return q+m*x;
	}
      else
	if(igrid<0)
	  return force_out*sqr(-x-barr)/2+grid[0];
	else
	  return force_out*sqr(+x-barr)/2+grid[ngrid];
    }
    
    //write
    void save()
    {
      FILE *fout=open_file(path.c_str(),"w");
      for(int i=0;i<=ngrid;i++) master_fprintf(fout,"%16.16 lg %16.16lg\n",-barr+i*width,grid[i]);
      close_file(fout);
    }
    
    //read
    void load()
    {
      FILE *fout=open_file(path.c_str(),"r");
      for(int igrid=0;igrid<=ngrid;igrid++)
	{
	  double xread;
	  fin>>xread>>grid[igrid];
	  if(!fin.good()) crash("reading line %d of \"%s\"",igrid,path.c_str());
	  int jgrid=floor((xread+barr+width/2)/width);
	  if(igrid!=jgrid) crash("found %d (%lg) when expecting %d",jgrid,xread,igrid);
	}
      fin.close();
    }
    
    //draw the chronological force
    void draw_force(const char *force_path)
    {
      double x_min=-barr*1.1;
      double x_max=+barr*1.1;
      double x_diff=x_max-x_min;
      int n=ceil(x_diff/width*10);
      if(n==0) n=1;
      double dx=x_diff/n;
      
      //compute 
      double *xy=new double[n+1];
      double *xz=new double[n+1];
#pragma omp parallel for
      for(int i=0;i<=n;i++)
	{
	  xy[i]=compute_pot_der(x_min+i*dx);
	  xz[i]=(compute_pot(x_min+i*dx+dx/10)-compute_pot(x_min+i*dx-dx/10))/(dx/5);
	}
      
      //write
      ofstream fout(force_path);
      for(int i=0;i<=n;i++) fout<<x_min+i*dx<<" "<<xy[i]<<endl;
      fout<<"&"<<endl;
      for(int i=0;i<=n;i++) fout<<x_min+i*dx<<" "<<xz[i]<<endl;
      fout.close();
      
      delete[] xy;
      delete[] xz;
    }
    
    //initialize
    void init()
    {
      ngrid=(2*barr+width/2)/width;
      grid.resize(ngrid+1);
      for(auto &g : grid) g=0;
    }
  };
}

#endif
  
